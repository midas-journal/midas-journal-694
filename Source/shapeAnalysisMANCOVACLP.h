// This file was automatically generated by:
//  /devel/linux/Slicer3_linux64/Slicer3-build/bin/GenerateCLP --InputXML /home/paniagua/Research/MANCOVA/InsightJournal/Submission09042009/Source/shapeAnalysisMANCOVA.xml --OutputCxx /home/paniagua/Research/MANCOVA/InsightJournal/Submission09042009/Source/shapeAnalysisMANCOVACLP.h
//
#include <stdio.h>
#include <stdlib.h>
#include <iostream>
#include <string.h>
#include <vector>
#include <map>

#include <itksys/ios/sstream>

#include "tclap/CmdLine.h"
#include "ModuleProcessInformation.h"

#ifdef WIN32
#define Module_EXPORT __declspec(dllexport)
#else
#define Module_EXPORT 
#endif

#if defined(main) && !defined(REGISTER_TEST)
// If main defined as a preprocessor symbol, redefine it to the expected entry point.
#undef main
#define main ModuleEntryPoint

extern "C" {
  Module_EXPORT char *GetXMLModuleDescription();
  Module_EXPORT int ModuleEntryPoint(int, char*[]);
}
#endif

extern "C" {
Module_EXPORT char XMLModuleDescription[] = 
"<?xml version=\"1.0\" encoding=\"utf-8\"?>\n"
"<executable>\n"
"  <category>Statistics</category>\n"
"  <title>MANCOVA Shape Analysis Tool</title>\n"
"  <description>Does shape analysis by permutation testing.</description>\n"
"  <version>0.0.1.$Revision: 1.5 $(alpha)</version>\n"
"  <documentation-url></documentation-url>\n"
"  <license></license>\n"
"  <contributor>Marc Niethammer, Beatriz Paniagua, Marc Macenko</contributor>\n"
"\n"
"  <parameters>\n"
"    <label>Analysis Parameters</label>\n"
"    <description>Parameters for the shape analysis</description>\n"
"	<!--  Comment Testing-->\n"
"\n"
"\n"
"    <file>\n"
"    <name>infile</name>\n"
"    <label>Input File</label>\n"
"    <channel>input</channel>\n"
"    <index>1</index>\n"
"    <description>File which contains all of the data to be analyzed. File is a list pointing to other data sources.</description>\n"
"    </file>\n"
"	\n"
"    <string>\n"
"    <name>outbase</name>\n"
"    <label>Name base for output files</label>\n"
"    <longflag>--out</longflag>\n"
"    <flag>o</flag>\n"
"    <default>statResult</default>\n"
"    <description>All output files will have this as their base.</description>\n"
"    </string>\n"
"	\n"
"    <integer>\n"
"    <name>numPerms</name>\n"
"    <label>Number of permutations to perform.</label>\n"
"    <longflag>--numPerms</longflag>\n"
"    <flag>n</flag>\n"
"    <description>Number of permutations to perform.</description>\n"
"    <default>10000</default>\n"
"    <constraints>\n"
"    <minimum>1</minimum>\n"
"    <step>1</step>\n"
"    </constraints>\n"
"    </integer>\n"
"	\n"
"    <integer>\n"
"    <name>numGroupTypes</name>\n"
"    <label>Number of different classification types.</label>\n"
"    <longflag>--numGroupTypes</longflag>\n"
"    <flag>g</flag>\n"
"    <description>Number of different classification types.</description>\n"
"    <default>1</default>\n"
"    <constraints>\n"
"    <minimum>1</minimum>\n"
"    <step>1</step>\n"
"    </constraints>\n"
"    </integer>\n"
"	\n"
"    <integer>\n"
"    <name>numIndependent</name>\n"
"    <label>Number of different independent variables associated with each subject.</label>\n"
"    <longflag>--numIndependent</longflag>\n"
"    <flag>i</flag>\n"
"    <description>Number of different independent variables associated with each subject.</description>\n"
"    <default>0</default>\n"
"    <constraints>\n"
"    <minimum>0</minimum>\n"
"    <step>1</step>\n"
"    </constraints>\n"
"    </integer>\n"
"	\n"
"    <integer>\n"
"    <name>testColumn</name>\n"
"    <label>Which column of the data is being tested (0 based). If this is a standard \"Group Test\", it will be one of the group columns. If it is an \"Interaction Test\", it will be one of the independent variable columns.</label>\n"
"    <longflag>--testColumn</longflag>\n"
"    <flag>t</flag>\n"
"    <description>Which column of the data is being tested (0 based). If this is a standard \"Group Test\", it will be one of the group columns. If it is an \"Interaction Test\", it will be one of the independent variable columns.</description>\n"
"    <default>0</default>\n"
"    <constraints>\n"
"    <minimum>0</minimum>\n"
"    <step>1</step>\n"
"    </constraints>\n"
"    </integer>\n"
"	\n"
"    <double>\n"
"    <name>significanceLevel</name>\n"
"    <label>What cutoff of p-values is considered significant. Only affects the FDR corrected results.</label>\n"
"    <longflag>--significanceLevel</longflag>\n"
"    <flag>p</flag>\n"
"    <description>What cutoff of p-values is considered significant. Only affects the FDR corrected results.</description>\n"
"    <default>0.05</default>\n"
"    <constraints>\n"
"    <minimum>0</minimum>\n"
"    <maximum>1</maximum>\n"
"    <step>.001</step>\n"
"    </constraints>\n"
"    </double>\n"
"\n"
"    <boolean>\n"
"    <name>writeZScores</name>\n"
"    <longflag>--writeZScores</longflag>\n"
"    <description>Writes out the z-scores. Only uses group assignments from the first group column currently. z-score of group A is computed with mean and standard deviation from group B and vice versa. z-scores are output based on the projections on the mean surface normal as well as the corresponding Mahalanobis distances (where no projection is performed).</description>\n"
"    <default>false</default>\n"
"    </boolean>\n"
"\n"
"    <boolean>\n"
"    <name>computeScaleFactorFromVolumes</name>\n"
"    <label>Compute scale factor from volumes.</label>\n"
"    <default>false</default>\n"
"    <longflag>--computeScaleFactorFromVolumes</longflag>\n"
"    <description>Reinterprets the scaling column values as volumes and compute the scaling factor from them. WARNING: This is different from the traditional file format where these scaling were already pre-computed.</description>\n"
"    </boolean>\n"
"	\n"
"    <boolean>\n"
"    <name>interactionTest</name>\n"
"    <label>Instead of a group test, simply test for statistically significant interaction of the data with a single independent variable.</label>\n"
"    <default>false</default>\n"
"    <longflag>--interactionTest</longflag>\n"
"    <flag>a</flag>\n"
"    <description>Instead of a group test, simply test for statistically significant interaction of the data with a single independent variable.</description>\n"
"    </boolean>\n"
"\n"
"    <boolean>\n"
"    <name>simpleCorrs</name>\n"
"    <label>Simple correlations (Spearman, Pearson).</label>\n"
"    <default>false</default>\n"
"    <longflag>--simpleCorrs</longflag>\n"
"    <description>Simple Spearman and Pearson correlations are computed, based on the normal to the average shape. This option is only valid in interaction test mode.</description>\n"
"    </boolean>\n"
"\n"
"    <boolean>\n"
"    <name>computeParametricP</name>\n"
"    <label>Simple corr: Parametric p-value.</label>\n"
"    <default>false</default>\n"
"    <longflag>--simpleCorrsParaP</longflag>\n"
"    <description>Computes the p-value parametrically for the simple correlation test.</description>\n"
"    </boolean>\n"
"\n"
"    <boolean>\n"
"    <name>surfListScale</name>\n"
"    <label>Scale all point data by the cube-root of the scale factor found in the input file. This is typically used for correcting differences such as varying intercranial volumes (ICV).</label>\n"
"    <default>false</default>\n"
"    <longflag>--scale</longflag>\n"
"    <flag>s</flag>\n"
"    <description>Scale all point data by the cube-root of the scale factor found in the input file. This is typically used for correcting differences such as varying intercranial volumes (ICV).</description>\n"
"    </boolean>\n"
"	\n"
"    <boolean>\n"
"    <name>KWMreadableInputFile</name>\n"
"    <label> Input data will be obtained from a KWMeshVisu readable feature (vector) file instead of the 3-d coordinates in a MeshFile.</label>\n"
"    <default>false</default>\n"
"    <longflag>--KWMinput</longflag>\n"
"    <flag>s</flag>\n"
"    <description> Input data will be obtained from a KWMeshVisu readable feature (vector) file instead of the 3-d coordinates in a MeshFile.</description>\n"
"    </boolean>\n"
"	\n"
"    <boolean>\n"
"    <name>debug</name>\n"
"    <label>Outputs additional debugging information.</label>\n"
"    <default>false</default>\n"
"    <longflag>--debug</longflag>\n"
"    <flag>d</flag>\n"
"    <description>Outputs additional debugging information.</description>\n"
"    </boolean>\n"
"\n"
"    <boolean>\n"
"    <name>useRoy</name>\n"
"    <label>Roy statistics.</label>\n"
"    <default>false</default>\n"
"    <longflag>--roy</longflag>\n"
"    <description>Uses Roy statistic for MANCOVA testing.</description>\n"
"    </boolean>\n"
"\n"
"    <boolean>\n"
"    <name>useWilks</name>\n"
"    <label>Wilks statistics.</label>\n"
"    <default>false</default>\n"
"    <longflag>--wilks</longflag>\n"
"    <description>Uses Wilks statistic for MANCOVA testing.</description>\n"
"    </boolean>\n"
"\n"
"    <boolean>\n"
"    <name>useHotelling</name>\n"
"    <label>Hotelling statistics.</label>\n"
"    <default>false</default>\n"
"    <longflag>--hotelling</longflag>\n"
"    <description>Uses Hotelling statistic for MANCOVA testing.</description>\n"
"    </boolean>\n"
"\n"
"    <boolean>\n"
"    <name>usePillai</name>\n"
"    <label>Pillai statistics.</label>\n"
"    <default>false</default>\n"
"    <longflag>--pillai</longflag>\n"
"    <description>Uses Pillai statistic for MANCOVA testing.</description>\n"
"    </boolean>\n"
"\n"
"    <boolean>\n"
"    <name>negativeCorrelation</name>\n"
"    <label>Negative correlation.</label>\n"
"    <default>false</default>\n"
"    <longflag>--negativeCorrelation</longflag>\n"
"    <description>For the simple (non-MANCOVA) correlation, test for negative correlation. (Only works in conjunction with parametric testing!)</description>\n"
"    </boolean>\n"
"\n"
"    <boolean>\n"
"    <name>positiveCorrelation</name>\n"
"    <label>Positive correlation.</label>\n"
"    <default>false</default>\n"
"    <longflag>--positiveCorrelation</longflag>\n"
"    <description>For the simple (non-MANCOVA) correlation, test for positive correlation.(Only works in conjunction with parametric testing!)</description>\n"
"    </boolean>\n"
"\n"
"    <boolean>\n"
"    <name>trendCorrelation</name>\n"
"    <label>Trend correlation.</label>\n"
"    <default>false</default>\n"
"    <longflag>--trendCorrelation</longflag>\n"
"    <description>For the simple (non-MANCOVA) correlation, test for correlation.</description>\n"
"    </boolean>\n"
"\n"
"    </parameters>\n"
"\n"
" </executable>\n"
"\n"
;

}

void
splitString (const std::string &text,
             const std::string &separators,
             std::vector<std::string> &words)
{
  const std::string::size_type n = text.length();
  std::string::size_type start = text.find_first_not_of(separators);
  while (start < n)
    {
    std::string::size_type stop = text.find_first_of(separators, start);
    if (stop > n) stop = n;
    words.push_back(text.substr(start, stop - start));
    start = text.find_first_not_of(separators, stop+1);
    }
}

void
splitFilenames (const std::string &text,
                std::vector<std::string> &words)
{
  const std::string::size_type n = text.length();
  bool quoted;
  std::string comma(",");
  std::string quote("\"");
  std::string::size_type start = text.find_first_not_of(comma);
  while (start < n)
    {
    quoted = false;
    std::string::size_type startq = text.find_first_of(quote, start);
    std::string::size_type stopq = text.find_first_of(quote, startq+1);
    std::string::size_type stop = text.find_first_of(comma, start);
    if (stop > n) stop = n;
    if (startq != std::string::npos && stopq != std::string::npos)
      {
      while (startq < stop && stop < stopq && stop != n)
         {
         quoted = true;
         stop = text.find_first_of(comma, stop+1);
         if (stop > n) stop = n;
         }
      }
    if (!quoted)
      {
      words.push_back(text.substr(start, stop - start));
      }
    else
      {
      words.push_back(text.substr(start+1, stop - start-2));
      }
    start = text.find_first_not_of(comma, stop+1);
    }
}

char *GetXMLModuleDescription()
{
   return XMLModuleDescription;
}

#define GENERATE_LOGO
#define GENERATE_XML \
  if (argc >= 2 && (strcmp(argv[1],"--xml") == 0)) \
    { \
    std::cout << GetXMLModuleDescription(); \
    return EXIT_SUCCESS; \
    }
#define GENERATE_TCLAP \
    std::string infile; \
    std::string outbase = "statResult"; \
    int numPerms = 10000; \
    int numGroupTypes = 1; \
    int numIndependent = 0; \
    int testColumn = 0; \
    double significanceLevel = 0.05; \
    bool writeZScores = false; \
    bool computeScaleFactorFromVolumes = false; \
    bool interactionTest = false; \
    bool simpleCorrs = false; \
    bool computeParametricP = false; \
    bool surfListScale = false; \
    bool KWMreadableInputFile = false; \
    bool debug = false; \
    bool useRoy = false; \
    bool useWilks = false; \
    bool useHotelling = false; \
    bool usePillai = false; \
    bool negativeCorrelation = false; \
    bool positiveCorrelation = false; \
    bool trendCorrelation = false; \
    bool echoSwitch = false; \
    bool xmlSwitch = false; \
    std::string processInformationAddressString = "0"; \
    std::string fullDescription("Description: "); \
    fullDescription += "Does shape analysis by permutation testing."; \
    if (!std::string("Marc Niethammer, Beatriz Paniagua, Marc Macenko").empty()) \
      { \
      fullDescription += "\nAuthor(s): Marc Niethammer, Beatriz Paniagua, Marc Macenko"; \
      } \
    if (!std::string("").empty()) \
      { \
      fullDescription += "\nAcknowledgements: "; \
      } \
    TCLAP::CmdLine commandLine (fullDescription, \
       ' ', \
      "0.0.1.$Revision: 1.5 $(alpha)" ); \
 \
      itksys_ios::ostringstream msg; \
    msg.str("");msg << "File which contains all of the data to be analyzed. File is a list pointing to other data sources.";    TCLAP::UnlabeledValueArg<std::string> infileArg("infile", msg.str(), 1, infile, "std::string", commandLine); \
 \
    msg.str("");msg << "All output files will have this as their base. (default: " << outbase << ")"; \
    TCLAP::ValueArg<std::string > outbaseArg("o", "out", msg.str(), 0, outbase, "std::string", commandLine); \
 \
    msg.str("");msg << "Number of permutations to perform. (default: " << numPerms << ")"; \
    TCLAP::ValueArg<int > numPermsArg("n", "numPerms", msg.str(), 0, numPerms, "int", commandLine); \
 \
    msg.str("");msg << "Number of different classification types. (default: " << numGroupTypes << ")"; \
    TCLAP::ValueArg<int > numGroupTypesArg("g", "numGroupTypes", msg.str(), 0, numGroupTypes, "int", commandLine); \
 \
    msg.str("");msg << "Number of different independent variables associated with each subject. (default: " << numIndependent << ")"; \
    TCLAP::ValueArg<int > numIndependentArg("i", "numIndependent", msg.str(), 0, numIndependent, "int", commandLine); \
 \
    msg.str("");msg << "Which column of the data is being tested (0 based). If this is a standard 'Group Test', it will be one of the group columns. If it is an 'Interaction Test', it will be one of the independent variable columns. (default: " << testColumn << ")"; \
    TCLAP::ValueArg<int > testColumnArg("t", "testColumn", msg.str(), 0, testColumn, "int", commandLine); \
 \
    msg.str("");msg << "What cutoff of p-values is considered significant. Only affects the FDR corrected results. (default: " << significanceLevel << ")"; \
    TCLAP::ValueArg<double > significanceLevelArg("p", "significanceLevel", msg.str(), 0, significanceLevel, "double", commandLine); \
 \
    msg.str("");msg << "Writes out the z-scores. Only uses group assignments from the first group column currently. z-score of group A is computed with mean and standard deviation from group B and vice versa. z-scores are output based on the projections on the mean surface normal as well as the corresponding Mahalanobis distances (where no projection is performed). (default: " << writeZScores << ")"; \
    TCLAP::SwitchArg writeZScoresArg("", "writeZScores", msg.str(), commandLine, writeZScores); \
 \
    msg.str("");msg << "Reinterprets the scaling column values as volumes and compute the scaling factor from them. WARNING: This is different from the traditional file format where these scaling were already pre-computed. (default: " << computeScaleFactorFromVolumes << ")"; \
    TCLAP::SwitchArg computeScaleFactorFromVolumesArg("", "computeScaleFactorFromVolumes", msg.str(), commandLine, computeScaleFactorFromVolumes); \
 \
    msg.str("");msg << "Instead of a group test, simply test for statistically significant interaction of the data with a single independent variable. (default: " << interactionTest << ")"; \
    TCLAP::SwitchArg interactionTestArg("a", "interactionTest", msg.str(), commandLine, interactionTest); \
 \
    msg.str("");msg << "Simple Spearman and Pearson correlations are computed, based on the normal to the average shape. This option is only valid in interaction test mode. (default: " << simpleCorrs << ")"; \
    TCLAP::SwitchArg simpleCorrsArg("", "simpleCorrs", msg.str(), commandLine, simpleCorrs); \
 \
    msg.str("");msg << "Computes the p-value parametrically for the simple correlation test. (default: " << computeParametricP << ")"; \
    TCLAP::SwitchArg computeParametricPArg("", "simpleCorrsParaP", msg.str(), commandLine, computeParametricP); \
 \
    msg.str("");msg << "Scale all point data by the cube-root of the scale factor found in the input file. This is typically used for correcting differences such as varying intercranial volumes (ICV). (default: " << surfListScale << ")"; \
    TCLAP::SwitchArg surfListScaleArg("s", "scale", msg.str(), commandLine, surfListScale); \
\
    msg.str("");msg << "Input data will be obtained from a KWMeshVisu readable feature (vector) file instead of the 3-d coordinates in a MeshFile. (default: " << KWMreadableInputFile << ")"; \
    TCLAP::SwitchArg KWMreadableInputFileArg("", "KWMinput", msg.str(), commandLine, KWMreadableInputFile); \
 \
    msg.str("");msg << "Outputs additional debugging information. (default: " << debug << ")"; \
    TCLAP::SwitchArg debugArg("d", "debug", msg.str(), commandLine, debug); \
 \
    msg.str("");msg << "Uses Roy statistic for MANCOVA testing. (default: " << useRoy << ")"; \
    TCLAP::SwitchArg useRoyArg("", "roy", msg.str(), commandLine, useRoy); \
 \
    msg.str("");msg << "Uses Wilks statistic for MANCOVA testing. (default: " << useWilks << ")"; \
    TCLAP::SwitchArg useWilksArg("", "wilks", msg.str(), commandLine, useWilks); \
 \
    msg.str("");msg << "Uses Hotelling statistic for MANCOVA testing. (default: " << useHotelling << ")"; \
    TCLAP::SwitchArg useHotellingArg("", "hotelling", msg.str(), commandLine, useHotelling); \
 \
    msg.str("");msg << "Uses Pillai statistic for MANCOVA testing. (default: " << usePillai << ")"; \
    TCLAP::SwitchArg usePillaiArg("", "pillai", msg.str(), commandLine, usePillai); \
 \
    msg.str("");msg << "For the simple (non-MANCOVA) correlation, test for negative correlation. (Only works in conjunction with parametric testing!) (default: " << negativeCorrelation << ")"; \
    TCLAP::SwitchArg negativeCorrelationArg("", "negativeCorrelation", msg.str(), commandLine, negativeCorrelation); \
 \
    msg.str("");msg << "For the simple (non-MANCOVA) correlation, test for positive correlation.(Only works in conjunction with parametric testing!) (default: " << positiveCorrelation << ")"; \
    TCLAP::SwitchArg positiveCorrelationArg("", "positiveCorrelation", msg.str(), commandLine, positiveCorrelation); \
 \
    msg.str("");msg << "For the simple (non-MANCOVA) correlation, test for correlation. (default: " << trendCorrelation << ")"; \
    TCLAP::SwitchArg trendCorrelationArg("", "trendCorrelation", msg.str(), commandLine, trendCorrelation); \
 \
    msg.str("");msg << "Echo the command line arguments (default: " << echoSwitch << ")"; \
    TCLAP::SwitchArg echoSwitchArg("", "echo", msg.str(), commandLine, echoSwitch); \
 \
    msg.str("");msg << "Produce xml description of command line arguments (default: " << xmlSwitch << ")"; \
    TCLAP::SwitchArg xmlSwitchArg("", "xml", msg.str(), commandLine, xmlSwitch); \
 \
    msg.str("");msg << "Address of a structure to store process information (progress, abort, etc.). (default: " << processInformationAddressString << ")"; \
    TCLAP::ValueArg<std::string > processInformationAddressStringArg("", "processinformationaddress", msg.str(), 0, processInformationAddressString, "std::string", commandLine); \
 \
try \
  { \
    /* Build a map of flag aliases to the true flag */ \
    std::map<std::string,std::string> flagAliasMap; \
    std::map<std::string,std::string> deprecatedFlagAliasMap; \
    std::map<std::string,std::string> longFlagAliasMap; \
    std::map<std::string,std::string> deprecatedLongFlagAliasMap; \
    /* Remap flag aliases to the true flag */ \
    std::vector<std::string> targs; \
    std::map<std::string,std::string>::iterator ait; \
    std::map<std::string,std::string>::iterator dait; \
    size_t ac; \
    for (ac=0; ac < static_cast<size_t>(argc); ++ac)  \
       {  \
       if (strlen(argv[ac]) == 2 && argv[ac][0]=='-') \
         { \
         /* short flag case */ \
         std::string tflag(argv[ac], 1, strlen(argv[ac])-1); \
         ait = flagAliasMap.find(tflag); \
         dait = deprecatedFlagAliasMap.find(tflag); \
         if (ait != flagAliasMap.end() || dait != deprecatedFlagAliasMap.end()) \
           { \
           if (ait != flagAliasMap.end()) \
             { \
             /* remap the flag */ \
             targs.push_back("-" + (*ait).second); \
             } \
           else if (dait != deprecatedFlagAliasMap.end()) \
             { \
             std::cout << "Flag \"" << argv[ac] << "\" is deprecated. Please use flag \"-" << (*dait).second << "\" instead. " << std::endl; \
             /* remap the flag */ \
             targs.push_back("-" + (*dait).second); \
             } \
           } \
         else \
           { \
           targs.push_back(argv[ac]); \
           } \
         } \
       else if (strlen(argv[ac]) > 2 && argv[ac][0]=='-' && argv[ac][1]=='-') \
         { \
         /* long flag case */ \
         std::string tflag(argv[ac], 2, strlen(argv[ac])-2); \
         ait = longFlagAliasMap.find(tflag); \
         dait = deprecatedLongFlagAliasMap.find(tflag); \
         if (ait != longFlagAliasMap.end() || dait != deprecatedLongFlagAliasMap.end()) \
           { \
           if (ait != longFlagAliasMap.end()) \
             { \
             /* remap the flag */ \
             targs.push_back("--" + (*ait).second); \
             } \
           else if (dait != deprecatedLongFlagAliasMap.end()) \
             { \
             std::cout << "Long flag \"" << argv[ac] << "\" is deprecated. Please use long flag \"--" << (*dait).second << "\" instead. " << std::endl; \
             /* remap the flag */ \
             targs.push_back("--" + (*dait).second); \
             } \
           } \
         else \
           { \
           targs.push_back(argv[ac]); \
           } \
         } \
       else if (strlen(argv[ac]) > 2 && argv[ac][0]=='-' && argv[ac][1]!='-') \
         { \
         /* short flag case where multiple flags are given at once ala */ \
         /* "ls -ltr" */ \
         std::string tflag(argv[ac], 1, strlen(argv[ac])-1); \
         std::string rflag("-"); \
         for (std::string::size_type fi=0; fi < tflag.size(); ++fi) \
           { \
           std::string tf(tflag, fi, 1); \
           ait = flagAliasMap.find(tf); \
           dait = deprecatedFlagAliasMap.find(tf); \
           if (ait != flagAliasMap.end() || dait != deprecatedFlagAliasMap.end()) \
             { \
             if (ait != flagAliasMap.end()) \
               { \
               /* remap the flag */ \
               rflag += (*ait).second; \
               } \
             else if (dait != deprecatedFlagAliasMap.end()) \
               { \
               std::cout << "Flag \"-" << tf << "\" is deprecated. Please use flag \"-" << (*dait).second << "\" instead. " << std::endl; \
               /* remap the flag */ \
               rflag += (*dait).second; \
               } \
             } \
           else \
             { \
             rflag += tf; \
             } \
           } \
         targs.push_back(rflag); \
         } \
       else \
         { \
         /* skip the argument without remapping (this is the case for any */ \
         /* arguments for flags */ \
         targs.push_back(argv[ac]); \
         } \
       } \
 \
   /* Remap args to a structure that CmdLine::parse() can understand*/ \
   std::vector<char*> vargs; \
   for (ac = 0; ac < targs.size(); ++ac) \
     {  \
     vargs.push_back(const_cast<char *>(targs[ac].c_str())); \
     } \
    commandLine.parse ( vargs.size(), (char**) &(vargs[0]) ); \
    infile = infileArg.getValue(); \
    outbase = outbaseArg.getValue(); \
    numPerms = numPermsArg.getValue(); \
    numGroupTypes = numGroupTypesArg.getValue(); \
    numIndependent = numIndependentArg.getValue(); \
    testColumn = testColumnArg.getValue(); \
    significanceLevel = significanceLevelArg.getValue(); \
    writeZScores = writeZScoresArg.getValue(); \
    computeScaleFactorFromVolumes = computeScaleFactorFromVolumesArg.getValue(); \
    interactionTest = interactionTestArg.getValue(); \
    simpleCorrs = simpleCorrsArg.getValue(); \
    computeParametricP = computeParametricPArg.getValue(); \
    surfListScale = surfListScaleArg.getValue(); \
    KWMreadableInputFile = KWMreadableInputFileArg.getValue(); \
    debug = debugArg.getValue(); \
    useRoy = useRoyArg.getValue(); \
    useWilks = useWilksArg.getValue(); \
    useHotelling = useHotellingArg.getValue(); \
    usePillai = usePillaiArg.getValue(); \
    negativeCorrelation = negativeCorrelationArg.getValue(); \
    positiveCorrelation = positiveCorrelationArg.getValue(); \
    trendCorrelation = trendCorrelationArg.getValue(); \
    echoSwitch = echoSwitchArg.getValue(); \
    xmlSwitch = xmlSwitchArg.getValue(); \
    processInformationAddressString = processInformationAddressStringArg.getValue(); \
  } \
catch ( TCLAP::ArgException e ) \
  { \
  std::cerr << "error: " << e.error() << " for arg " << e.argId() << std::endl; \
  return ( EXIT_FAILURE ); \
  }
#define GENERATE_ECHOARGS \
if (echoSwitch) \
{ \
std::cout << "Command Line Arguments" << std::endl; \
std::cout << "    infile: " << infile << std::endl; \
std::cout << "    outbase: " << outbase << std::endl; \
std::cout << "    numPerms: " << numPerms << std::endl; \
std::cout << "    numGroupTypes: " << numGroupTypes << std::endl; \
std::cout << "    numIndependent: " << numIndependent << std::endl; \
std::cout << "    testColumn: " << testColumn << std::endl; \
std::cout << "    significanceLevel: " << significanceLevel << std::endl; \
std::cout << "    writeZScores: " << writeZScores << std::endl; \
std::cout << "    computeScaleFactorFromVolumes: " << computeScaleFactorFromVolumes << std::endl; \
std::cout << "    interactionTest: " << interactionTest << std::endl; \
std::cout << "    simpleCorrs: " << simpleCorrs << std::endl; \
std::cout << "    computeParametricP: " << computeParametricP << std::endl; \
std::cout << "    surfListScale: " << surfListScale << std::endl; \
std::cout << "    KWMreadableInputFile: " << KWMreadableInputFile << std::endl; \
std::cout << "    debug: " << debug << std::endl; \
std::cout << "    useRoy: " << useRoy << std::endl; \
std::cout << "    useWilks: " << useWilks << std::endl; \
std::cout << "    useHotelling: " << useHotelling << std::endl; \
std::cout << "    usePillai: " << usePillai << std::endl; \
std::cout << "    negativeCorrelation: " << negativeCorrelation << std::endl; \
std::cout << "    positiveCorrelation: " << positiveCorrelation << std::endl; \
std::cout << "    trendCorrelation: " << trendCorrelation << std::endl; \
std::cout << "    echoSwitch: " << echoSwitch << std::endl; \
std::cout << "    xmlSwitch: " << xmlSwitch << std::endl; \
std::cout << "    processInformationAddressString: " << processInformationAddressString << std::endl; \
}
#define GENERATE_ProcessInformationAddressDecoding \
ModuleProcessInformation *CLPProcessInformation = 0; \
if (processInformationAddressString != "") \
{ \
sscanf(processInformationAddressString.c_str(), "%p", &CLPProcessInformation); \
}
#define PARSE_ARGS GENERATE_LOGO;GENERATE_XML;GENERATE_TCLAP;GENERATE_ECHOARGS;GENERATE_ProcessInformationAddressDecoding;
